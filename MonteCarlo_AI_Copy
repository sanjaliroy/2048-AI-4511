from random import randint
from BaseAI_3 import BaseAI
from ComputerAI_3 import ComputerAI
from Displayer_3 import Displayer
from Grid_3 import Grid
import math
import random


directionVectors = (UP_VEC, DOWN_VEC, LEFT_VEC, RIGHT_VEC) = ((-1, 0), (1, 0), (0, -1), (0, 1))
(PLAYER_TURN, COMPUTER_TURN) = (0, 1)
computerAI  = ComputerAI()

# class for the nodes of the game tree
class Node():
   def __init__(self, state, parent = None, prev_move = None):
       self.state = state
       self.parent = parent
       self.prev_move = prev_move
       self.children = []
       self.total_value = 0
       self.total_playouts = 0
       self.possible_moves = self.state.getAvailableMoves()

   def add_child(self, child_node):
       self.children.append(child_node)
  
class montecarloAI(BaseAI):
    def getMove(self, grid):
       # based off implementation found in the AI textbook
        cGrid = grid.clone()
        root = Node(cGrid)
        curr = root
        while (root.total_playouts < 10):
           # if curr = leaf
            if (curr.children == []):
               # if the node has 0 playouts
                if (curr.total_playouts == 0):
                   val = self.rollout(curr)
                   self.backProp(val, curr)
                   curr = root
                else:
                   # if node does not have 0 playouts
                   # all the possible moves become children
                    for move in curr.possible_moves:
                        if move != None and move >= 0 and move < 4:
                            grid_copy = curr.state
                            if grid_copy.canMove([move]):
                                grid_copy.move(move)
                            else:
                                print("Invalid PlayerAI Move")
                        else:
                            print("Invalid PlayerAI Move - 1")
                        child = curr.add_child(Node(grid_copy, curr, move))
                       # setting the parent of each child to the current node
                   # choose the first node because all have number of playouts = 0
                    curr = curr.children[0]
           # if curr is NOT a leaf
            else:
                max_val = 0
                max_val_index = 0
               # for each child
                for child in curr.children:
                   # retrieve UCB val
                    UCB_val = self.UCB1(child)
                   # if UCB is greater than current max val
                    if UCB_val > max_val:
                       max_val = UCB_val
                       # take note of index of child in list of children
                       max_val_index = curr.children.index(child)
               # current node is the child with maximum value
                curr = curr.children[max_val_index]
        max_total_val = 0
        max_index = 0
        for child in root.children:
           if child.total_value > max_total_val:
               max_total_val = child.total_value
               root.children.indexof(child) = max_index
        return root.children[max_index].prev_move # the move in ACTIONS(state) whose node has highest number of playouts
  
    def rollout(self, node):
       while True:
           if node.state.getMaxTile() == 2048:
                return 2048
           # if tiles are full
           if not node.state.canMove():
                return node.state.getMaxTile()
           else:
                node.state = self.simulate(node)

    def simulate(self, action, node):
        turn = PLAYER_TURN
        state_copy = node.state
        while state_copy.canMove():
            if turn == PLAYER_TURN:
               move = random.choice(node.possible_actions)
               # Validate Move
               if move != None and move >= 0 and move < 4:
                    if state_copy.canMove([move]):
                        state_copy.move(move)
                    else:
                        print("Invalid PlayerAI Move")
               else:
                    print("Invalid PlayerAI Move - 1")
            else:
                move = computerAI.getMove(state_copy)
                # Validate Move
                if move and state_copy.canInsert(move):
                    state_copy.setCellValue(move, state_copy.getNewTileValue())
                else:
                    print("Invalid Computer AI Move")
            turn = 1 - turn
        return state_copy
  
    def backProp(self, val, node):
       curr = node
       curr.total_value = val + curr.total_value
       curr.total_playouts = curr.total_playouts + 1
       while True:
           curr = curr.parent
           curr.backProp(val, curr)
           if curr.parent == None:
               break
  
   # PARAM: Node object node
   # using UCT formula (upper confidence bound applied to trees)
    def UCB1(self, node):
       if node.total_playouts == 0:
           return float('inf')
       C = math.sqrt(2) # textbooks says this is works well theoretically
       return ((node.total_wins / node.total_playouts) +
                   (C * math.sqrt(math.log(node.parent.total_playouts) / node.total_playouts)))
              

